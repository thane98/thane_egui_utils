use crate::{ListModel, ViewItem};

/// A utility for showing filtered data on a UI by generating a "proxy model".
pub struct FilterProxyBuilder {
    filter_expr: String,
    requires_refresh: bool,
    proxy_indices: Vec<usize>,
}

impl Default for FilterProxyBuilder {
    fn default() -> Self {
        Self {
            filter_expr: String::new(),
            requires_refresh: true,
            proxy_indices: vec![],
        }
    }
}

impl FilterProxyBuilder {
    /// Retrieve the index of an item in the source model from its index in the proxy model.
    pub fn source_index<M, I>(&self, index: usize, source_model: &M) -> Option<usize>
    where
        M: ListModel<I>,
    {
        // The client might call this without refreshing after a source model change (but they shouldn't).
        // Compare against the source model's length to be safe.
        self.proxy_indices
            .get(index)
            .and_then(|real_index| (*real_index < source_model.len()).then_some(*real_index))
    }

    /// Retrieve the proxy index of an item from its index in the source model.
    pub fn proxy_index(&self, source_index: usize) -> Option<usize> {
        self.proxy_indices
            .iter()
            .enumerate()
            .find_map(|(proxy_index, src)| (*src == source_index).then_some(proxy_index))
    }

    /// Access this proxy's filter expression. The function must return true if the filter changes.
    pub fn with_filter_expr(&mut self, func: impl FnOnce(&mut String) -> bool) {
        if func(&mut self.filter_expr) {
            self.requires_refresh = true;
        }
    }

    /// Request that the filter proxy refresh its indices.
    pub fn request_refresh(&mut self) {
        self.requires_refresh = true;
    }

    /// Build a filtered view of a source model using this proxy's filter expression.
    /// Will ONLY trigger a refresh when required. There are three cases for this:
    /// * First time building a proxy (detected automatically)
    /// * Filter expression was altered (detected automatically)
    /// * Source model was changed. YOU must tell the proxy when this happened.
    pub fn model<'a, M, I>(
        &'a mut self,
        requires_refresh: bool,
        model: &'a M,
    ) -> FilterProxyModel<'a, M>
    where
        M: ListModel<I>,
        I: ViewItem,
    {
        if self.requires_refresh || requires_refresh {
            self.requires_refresh = false;
            self.proxy_indices.clear();
            for i in 0..model.len() {
                let matches_filter = model
                    .item(i)
                    .map(|item| {
                        let matches_search_by_index = (i + 1).to_string() == self.filter_expr;
                        let lowercase_filter_expr = self.filter_expr.to_lowercase();
                        let matches_search_by_name = item.with_text(|text| {
                            text.to_lowercase().contains(&lowercase_filter_expr)
                        });
                        matches_search_by_index || matches_search_by_name
                    })
                    .unwrap_or_default();
                if matches_filter {
                    self.proxy_indices.push(i);
                }
            }
        }

        FilterProxyModel {
            proxy_indices: &self.proxy_indices,
            model,
        }
    }
}

/// A filtered view of a [ListModel] generated by a [FilterProxyBuilder].
pub struct FilterProxyModel<'a, M> {
    proxy_indices: &'a [usize],
    model: &'a M,
}

impl<M, I> ListModel<I> for FilterProxyModel<'_, M>
where
    M: ListModel<I>,
{
    fn is_empty(&self) -> bool {
        self.proxy_indices.is_empty()
    }

    fn len(&self) -> usize {
        self.proxy_indices.len()
    }

    fn item(&self, index: usize) -> Option<&I> {
        self.proxy_indices
            .get(index)
            .and_then(|source_index| self.model.item(*source_index))
    }

    fn item_mut(&mut self, _: usize) -> Option<&mut I> {
        unimplemented!("modify the source model instead")
    }

    fn add(&mut self, _item: I) {
        unimplemented!("modify the source model instead")
    }

    fn insert(&mut self, _: usize, _: I) {
        unimplemented!("modify the source model instead")
    }

    fn remove(&mut self, _index: usize) {
        unimplemented!("modify the source model instead")
    }

    fn swap_items(&mut self, _: usize, _: usize) {
        unimplemented!("modify the source model instead")
    }

    fn copy(&mut self, _: usize, _: usize) {
        unimplemented!("modify the source model instead")
    }

    fn row_to_index(&self, row_number: usize) -> Option<usize> {
        self.proxy_indices
            .get(row_number)
            .and_then(|index| self.model.row_to_index(*index))
    }
}
